# 深入浅出node.js

## 第2章 模块机制  

* 如果是`.node`和`.json`文件，在传递给`require()`的标识符中带上扩展名,会加快一点速度.  
* 同步配合缓存,可以大幅度缓解`Node`单线程中国阻塞式调用的缺陷  
* 分析标识符的顺序:对应文件---将目录当作包处理---->
package.json---main属性指定错误或者package.json不存在---->
index.js/index.json/index.node-----没有成功定位任何文件---->
进入下一个模块路径进行查找------模块路径数组被遍历完毕,仍然没有查找到目标文件----->
抛出查找失败异常

### 2.3

### 2.4 

* `JavaScript` 的一个典型弱点是位运算 
    `JavaScript` 的位运算参照`Java`的位运算实现,
    但是 `Java` 的位运算是在 `int` 型数字的基础上进行的,
    而 `JavaScript` 中只有 `double` 型的数据类型,
    在进行位运算的过程中,
    需要将 `double` 型转换为 `int` 型,然后再进行.

* 一个平台下的 `.node` 文件在另一个平台下是无法加载执行的, 必须重新用各自
平台下的编译器编译为正确的 `.node` 文件  

### 2.6.3  

* 全局模式安装并不是将一个模块包安装为一个全局包的意思,它并不意味着可以从任何地方通过 `require()` 来引用它.  

* 全局模式是将一个包安装为全局可用的可执行命令.  
 
* 通过全局模式安装的所有包都被安装进了一个统一的目录下,这个目录可以通过如下方式推算出来:  
```JavaScript
  path.resolve(process.execPath, '..', 'lib', 'node_modules');
```
* 如果 `Node` 可执行文件的位置是 `/user/local/bin/node` ,那么模块目录就是 
`user/local/lib/node_modules`.  

### 2.7.2  

* `AMD` 规范是 `CommonJS` 模块规范的一个延伸.  

* `CMD` 规范由国内的 `玉伯` 提出,与 `AMD` 的主要区别在于定义模块和依赖引入的部分.  

* 与 `AMD` 模块规范相比, `CMD` 模块更接近于 `Node` 对 `CommonJS` 规范的定义.  

## 第三章 异步I/O

* 伴随着异步 `I/O` 的还有事件驱动和单线程,它们构成 `Node` 的基调.  

* `Nginx` 与 `Node` 的区别:  
    Nginx具备面向客户端管理连接的强大能力,但是它背后依然受限于各种同步方式的编程语言.  
    Node却是全方位的,既可以作为服务器端去处理客户端带来的大良并发请求,也能作为客户端向网络中的各个应用进行并发请求.  

### 3.1.1  

* `I/O` 是昂贵的,分布式 `I/O`是更昂贵的.  

* 只有后端能够更快速响应资源,才能让前端的体验变好.  

### 3.1.2  

* 添加硬件资源是一种提升服务质量的方式,但它不是唯一的方式.  

* 单线程同步编程模型会因阻塞 `I/O` 导致硬件资源得不到更优的使用.多线程编程模型也因为编程中的死锁/状态同步等问题让开发人员头疼.  

### 3.2.1  

* 从实际效果而言,异步和非阻塞都达到了我们并行 `I/O` 的目的.  

* 但是从计算机内核 `I/O` 而言,异步/同步和阻塞/非阻塞实际上是两回事.  

* 操作系统内核对于 `I/O` 只有两种方式: 阻塞与非阻塞.  

* 阻塞 `I/O` 的一个特点是调用之后一定要等到系统内核层面完成所有操作后,调用才结束.  

* 非阻塞 `I/O` 则会在调用之后立即返回.  

* 轮询:  
    由于非阻塞 `I/O` 并没有完成一次完整的 `I/O` ,立即返回的并不是业务层期望的数据,而仅仅是当前调用的状态.为了获取完整的数据,应用程序需要重复调用 `I/O` 操作来确认是否完成.这种重复调用判断操作是否完成的技术叫做轮询.  

* 现存的轮询技术主要有: `read` `select` `poll` `epoll` `kqueue`.  

### 3.2.3  

* 我们常提到 `Node` 是单线程的,这里的单线程仅仅只是 `JavaScript` 执行在单线程中罢了.在 `Node` 中,无论是 `*nix` 还是 `Windows` 平台,内部实现 `I/O` 任务的另有线程池.  

### 3.3.1  

* `Node` 的执行模型 -- 事件循环.正是它使得回调函数十分普遍.  

* `事件循环` 是一个典型的 `生产者/消费者` 模型.  

* 在 `Windows` 下,这个循环基于 `IOCP` 创建,而在 `*nix` 下则基于多线程创建.  

### 3.3.3  

* 从 `JavaScript` 发起调用到内核执行完 `I/O` 操作的过渡过程中,存在一种中间产物,它叫做 `请求对象`  

* 请求对象是异步 `I/O` 过程中的重要中间产物,所有的状态都保存在这个对象中,包括送入线程池等待执行以及 `I/O` 操作完毕后的回调处理  

### 3.3.4  

* 组装号请求对象、送入 `I/O` 线程池等待执行，实际上完成了异步 `I/O` 的第一部分.回调通知是第二部分.  

* 事件循环、观察者、请求对象、`I/O`线程池这四者共同构成了 `Node` 异步 `I/O` 模型的基本要素。  

### 3.3.5  

* 除了 `JavaScript` 是单线程外，`Node` 自身其实是多线程的，只是 `I/O` 线程使用的 `CPU` 较少。  
* 除了用户代码无法并行执行外，所有的 `I/O` （磁盘 `I/O` 和网络 `I/O` 等）则是可以并行起来的。  

### 3.4.2  

* 采用定时器需要动用红黑树，创建定时器对象和迭代等操作，所以 `setTimeout(fn, 0)` 的方式较为浪费性能。  

* 相比之下 `process.nextTick()` 方法的操作相对较为轻量。  

* 定时器中采用红黑树的操作时间复杂度为 `0(lg(n))` ，`nextTick()` 的时间复杂度为 `0(1)` 。相较之下，后则更高效。  

### 3.4.3  

* `process.nextTick()` 中的回调函数执行的优先级要高于 `setImmediate()` （中回调函数执行的优先级）。  

* `process.nextTick()` 属于 `idle` 观察者， `setImmediate()` 属于 `check` 观察者。  

* 事件循环对于观察者的检查是有先后顺序的：  
> idle -> I/O -> check  

* 在具体实现上：`process.nextTick()` 的回调函数保存在一个数组中， `setImmediate()` 的结果（读者注：此处应该是回调函数）则保存在链表中。  

* 在行为上：`process.nextTick()` 在每轮循环会将数组中的回调函数全部执行完，而 `setImmediate()` 在每轮循环中执行链表中的一个回调函数。  

### 3.5  

* 下面是几种经典的服务器模型，这里列出他们的优缺点。  
> 1. 同步式：一次只能处理一个请求，并且其余请求都处于等待状态。
> 2. 每进程/每请求：为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性，因为系统资源就只有那么多。  
> 3. 每线程/每请求：为每一个请求启动一个线程来处理。尽管线程比进程要轻量，但是由于每个线程都占用一定内存，当大并发请求到来时，内存将会很快用光，导致服务器缓慢。  

* `Nginx` 采用和 `Node` 相同的事件驱动。但是不同之处在于：  
> Nginx 采用纯 C 写成，性能较高，但是它仅适合于做 Web 服务器，用于反向代理或负载均衡等服务，在处理业务方面较为欠缺。  
> Node 则是一套高性能的平台，可以利用它构建与 Nginx 相同的功能，也可以处理各种具体业务，而且与背后的网络保持异步畅通。  
> 两者相比，Node 没有 Nginx 在 Web 服务器方面那么专业，但场景更大，自身性能也不错。  

## 第四章 异步编程  


### 4.1.2

* 偏函数用法是指创建一个调用另外一个部分（参数或变量已经预置的函数）的函数的用法。（读者：和函数柯里化不同）  

### 4.2.1

* `Node` 带来的最大的特性莫过于基于事件驱动的非阻塞 `I/O` 模型，这是它的灵魂所在。  

### 4.2.2

* `Node` 异步编程的难点：  
  * 难点1：异常处理
  * 难点2：函数嵌套过深
  * 难点3：阻塞代码
  * 难点4：多线程编程
  * 难点5：异步转同步

* 在自行编写的异步方法上，需要遵守下面的原则：  
> 原则一：必须执行调用者传入的回调函数；
> 原则二：正确传递回异常供调用者判断。

* 在编写异步方法时，只要将异常正确地传递给用户的回调方法即可，无须过多处理。  

### 4.3

* 目前，异步编程的主要解决方案有如下3种：  
  * 事件发布/订阅模式
  * `Promise` / `Deferred` 模式
  * 流程控制库

### 4.3.1

* 事件监听器模式是一种广泛用于异步编程的模式，是回调函数的事件化，又称发布/订阅模式。  

* 所谓 `雪崩问题` ，就是在高访问量、大并发量的情况下缓存失效的情景，此时大量的请求同时涌入数据库中，数据库无法同时承受如此大的查询请求，进而往前影响到网站整体的响应速度。  

* 利用事件队列解决雪崩问题：  
```javascript
  var proxy = new events.EventEmitter();
  var status = 'ready';
  var select = function(callback) {
    proxy.once('select', callback);
    if (status === 'ready') {
      status = 'pending';
      db.select('SQL', function(results) {
        proxy.emit('selected', results);
        status = 'ready';
      });
    }
  };
```

### 4.3.3  

* `async.series` 方法：异步的串行执行  

* `async.parallel` 方法：异步的并行执行  

* `async.waterfall` 方法：异步调用的依赖处理  

* `async.auto` 方法：自动依赖处理  

## 第五章 内存控制  

### 5.1.2  

* 在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在 `Node` 中通过 `JavaScript` 使用内存时就会发现只能使用部分内存（64位系统下约为1.4GB，32位系统下约为0.7GB）。  

* 受 V8 的垃圾回收限制的主要是 V8 的堆内存。  



### 5.1.3 V8 的对象分配

* 在 `V8` 中，所有的 `JavaScript` 对象都是通过堆来进行分配的。  

* `V8` 限制堆大小的表层原因：`V8` 最初为浏览器而设计，不太可能遇到使用大量内存的场景。  

* `V8` 限制堆大小的深层原因：受 `V8` 的垃圾回收机制的限制。  

* `V8` 对堆大小的限制可以打开。  

### 5.1.4 V8 的垃圾回收机制  

* V8 主要的垃圾回收策略主要基于*分代式垃圾回收机制*。  

* 在分代的基础上，新生代中的对象主要通过 `Scavenge` 算法进行垃圾回收。在 `Scavenge` 的具体实现中，主要采用了 `Cheney` 算法。  

* `Scavenge` 的缺点是只能使用堆内存中的一半，但是在时间效率上有优异的表现。是典型的牺牲空间换取时间的算法。  

* V8 在老生代中主要采用了 `Mark-Sweep` 和 `Mark-Compace` 相结合的方式进行垃圾回收。  

* 为了避免出现 `JavaScript` 应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为*全停顿（stop-the-world）。  

### 5.1.5 查看垃圾回收日志  

* 查看垃圾回收日志的方式主要是在启动时添加 `--trace_gc`参数。

* 在 V8 中通过 `delete` 删除对象的属性可能干扰 V8 的优化，所以通过赋值方式解除引用更好。  

### 5.2.2 闭包  

* 在 `JavaScript` 中，实现外部作用域访问内部作用域中变量的方法叫做闭包（closure）。  
## 第6章 理解 Buffer  

### 6.1.1 Buffer 结构  

* `Buffer` 是一个典型的 JavaScript 与 C++ 结合的模块，它将性能相关部分用 C++ 实现，将非性能相关的部分用 JavaScript 实现。  

* 由于 Buffer 太过常见， Node 在进程启动时就已经加载了它，并将其放在全局对象（global）上。所以在使用 Buffer 时，无须通过 require() 即可直接使用。  

### 6.1.2 Buffer 对象  

* Buffer 对象类似于数组，它的元素为 16 进制的两位数，即 0 到 255 的数值。  

### 6.1.3 Buffer 内存分配  

* Buffer 对象的内存分配不是在 V8 的堆内存中，而是在 Node 的 C++ 层面实现内存的申请的。  

* 为了高效地使用申请来的内存，Node 采用了 slab 分配机制。  

### 6.2 Buffer 转换  

* Buffer 对象可以与字符串之间相互转换。  

* 一个 Buffer 对象可以存储不同编码类型的字符串转码的值。  

* Buffer 的 isEncoding() 可以判断编码是否支持转换。  

### 6.3 Buffer 的拼接  

* setEncoding() 目前只能处理 UTF-8、Base64和UCS-2/UTF-16LE 这3种编码。  

* 正确的拼接方式是用一个数组来存储接收到的所有 Buffer 片段并记录下所有片段的总长度，然后调用 Buffer.concat() 方法生成一个合并的 Buffer 对象。  

### 6.4 Buffer 与性能  

* Buffer 在文件 I/O 和网络 I/O 中运用广泛，尤其在网络传输中，它的性能举足轻重。  

* 通过预先转换静态内容为 Buffer 对象，可以有效地减少 CPU 的重复使用，节省服务器资源。  

* Buffer 的使用除了与字符串的转换有性能损耗外，在文件的读取时，有一个 highWaterMark 设置对性能的影响至关重要。  

* 读取一个相同的大文件时， highWaterMark 值的大小与读取速度的关系：该值越大，读取速度越快。  


## 第七章 网络编程  

> Node 是一个面向网络而生的平台，它具有事件驱动、无阻塞、单线程等特性，具备良好的可伸缩性，使得它十分轻量，适合在分布式网络中扮演各种各样的角色。  

## 7.1 构建 TCP 服务  

* OSI模型由七层组成：物理层、数据链结层、网络层、传输层、会话层、表示层、应用层。  

* OSI 七层协议示意：  

        HTTP / SMTP / IMAP 等   ：  应用层  
        加密 / 解密 等           ：  表示层  
        通信连接 / 维持会话      ：  会话层  
        TCP / UDP               ：  传输层  
        IP                      ：  网络层  
        网络特有的链路接口        ：  链路层  
        网络物理硬件             ：  物理层  

* TCP 全名传输控制协议，在 OSI 模型中属于传输层协议。  

* TCP 是面向连接的协议，其显著的特征是在传输之前需要 3 次握手形成会话。  

* 只有在会话形成之后，服务器端和客户端之间才能互相发送数据。  

* TCP 针对网络中的小数据包有一定的优化策略：Nagle 算法。  

* Nagle 算法要求缓冲区的数据达到一定数量或者一定时间后才将其发出，所以小数据包会被 Nagel 算法合并，以此来优化网络。  

* Nagle 算法优化虽然使网络带宽呗有效地使用，但是数据有可能被延迟发送。  

* 在 Node 中，由于 TCP 默认开启了 Nagle 算法，可以调用 socket.setNoDelay(true) 去掉 Nagle 算法。  

* UDP 又称用户数据包协议，与 TCP 一样同属网络传输层。  

* UDP 与 TCP 最大的不同是 UDP 不是面向连接的。  

* UDP 提供面向事务的简单不可靠信息传输服务，无需连接，资源消耗低，处理快速且灵活。  

* UDP 常应用在那种偶尔丢一两个数据包也不会产生重大影响的场景，比如音频、视频等。  

### 7.3 构建 HTTP 服务   

* TCP 与 UDP 都属于网络传输层协议，如果要构造高效的网络应用，就应该从传输层进行着手。  

* 对于经典的应用场景，则无须从传输层协议入手构造自己的应用，比如 HTTP 或 SMTP 等，这些经典的应用层协议对于普通应用而言绰绰有余。  

* HTTP 的全称是**超文本传输协议**，英文写作 **HyperText Transfer Protoclo** 。  

* HTTP 构建在 TCP 之上，属于应用层协议。在 HTTP 的两端是服务器和浏览器，即著名的 B/S 模式，如今精彩纷呈的 Web 即是 HTTP 的应用。  

* HTTP 的特点是：基于请求响应式的，以一问一答的方式实现服务，虽然基于 TCP 会话，但是本身确并无会话的特点。  

* 在 Node 中，HTTP 服务继承自 TCP 服务器（net 模块），它能够与多个客户端保持连接，由于其采用事件驱动的形式，并不为每一个连接创建额外的线程或进程，保持很低的内存占用，所以能实现高并发。  

* HTTP 服务与 TCP 服务模型有区别的地方在于，在开启 keepalive 后，一个 TCP 会话可以用于多次请求和响应。  

* TCP 服务以 connnection 为单位进行服务，HTTP 服务以 request 为单位进行服务。  

* 为了重用 TCP 连接，http 模块包含一个默认的客户端代理对象 http.globalAgent。它对每个服务器端（host + port）创建的连接进行了管理，默认情况下，通过 clientRequest 对象对同一个服务端发起的 HTTP 请求最多可以创建 5 个连接。  

### 7.4 构建 WebSocket 服务  

* WebSocket 协议与 Node 之间配合堪称完美：  
  * WebSocket 客户端基于事件的变成模型与 Node 中自定义事件相差无几。  
  * WebSocket 实现了客户端与服务器端之间的长连接，而 Node 事件驱动的方式十分擅长与大量的客户端保持高并发连接。  

* WebSocket 与传统 HTTP 有如下好处：  
  * 客户端与服务端只建立一个 TCP 连接，可以使用更少的连接。  
  * WebSocket 服务器端可以推送数据到客户端，这远比 HTTP 请求响应模式更灵活、更高效。  
  * 有更轻量的协议头，减少数据传送量。  

* 在 WebSocket 之前，网页客户端与服务端进行通信最高效的是 **Comet** 技术。  

* Comet 技术的实现细节是采用长轮询（long-polling）或 iframe 流。  

* 长轮询的原理是：客户端向服务端发起请求，服务端只在超时或有数据响应时断开连接（res.end()），客户端在收到数据或者超时后重新发起请求。这个请求行为拖着长长的尾巴，是故用 Comet（彗星）来命名它。  

* WebSocket 协议主要分为两个部分：握手和数据传输。  

* WebSocket 没有在 HTTP 的基础上模拟服务器的推送，而是在 TCP 上定义独立的协议。但是 WebSocket 的握手部分是由 HTTP 完成的。  

### 7.5 网络服务与安全  

* SSL：Secure Sockets Layer，安全套接层。  

* TLS：Transport Layer Security，安全传输层协议。  

* Node 在网络安全上提供了 3 个模块，分别是 **cypto、tls、https**。  


## 第8章 构建Web应用

### 8.2 数据上传

* `Content-Type: multipart/form-data; boundary=AaB03x`：  
  * 本次提交的内容是由多部分构成的。  
  * boundary=AaB03x 指定的是每部分内容的分界符
  * AaB03x 是随机生成的一段字符串。报文体的内容通过在它前面添加 -- 进行分隔，报文结束时在它前后都加上 -- 表示结束。  
  * 另外 Content-Length 的值必须确保是报文体的长度。  

* 数据上传与安全：
  1. 内存限制  
    * 在解析表单、 JSON 和 XML 部分，采用的策略是先保存用户提交的所有数据，然后再解析处理，最后才传递给业务逻辑。
    * 这种方式存在的潜在问题是：仅仅适合数据量小的提交，一旦数据量过大，存在内存溢出风险。  
    * 解决方案主要有两种：
      1. 限制上传内容的大小，一旦超过限制，停止接收数据，并响应 400 状态码。  
      2. 通过流式解析，将数据导向磁盘中， Node 只保留文件路径等小数据。  
  2. CSRF 全程是 Cross-Site Request Forgery ，中文意思为*跨站请求伪造*。  
    * 一种解决 CSRF 攻击的方案是添加随机值的方式。  
    * CSRF漏洞检测：
      * 检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。  
      * 随着对CSRF漏洞研究的不断深入，不断涌现出一些专门针对CSRF漏洞进行检测的工具，如CSRFTester，CSRF Request Builder等  
      * 以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。  
### 8.3 路由解析

* 三种路由方式：文件路径、MVC、RESTful。  

* 文件路径型：分为静态文件、动态文件两种类型。  

* MVC 模式如何根据 URL 做路由映射，有两个分支实现：
  1. 手工关联映射。这种方式有一个对应的路由文件来将 URL 映射到对应的控制器。  
  2. 自然关联映射。这种方式按一种约定的方式自然而然地实现了路由，而无需去维护路由映射。  

* REST 的全称是 Representational State Transfer ，中文含义为*表现层状态转化*。  

* 符合 REST 规范的设计，我们称为 RESTful 设计。它的设计哲学主要将服务器端提供的内容实体看作一个资源，并表现在 URL 上。  

* REST 的设计就是：通过 URL 设计资源、请求方法定义资源的操作，通过 Accept 决定资源的表现形式。  

* RESTful 与 MVC 设计并不冲突，而且是更好的改进。相比 MVC ，RESTful 只是将 HTTP 请求方法也加入了路由的过程，以及在 URL 路径上体现得更资源化。  

### 8.4 中间件

* 中间件与性能：
  1. 编写高效的中间件  
    * 使用高效的方法。必要时通过 jsperf.com 测试基准性能  
    * 缓存需要重复计算的结果。  
    * 避免不必要的计算。  
  2. 合理利用路由，避免不必要的中间件执行  

### 8.5 页面渲染

* MIME 的全称是 Multipurpose Internet Mail Extensions。  

* Content-Disposition 字段影响的行为是客户端会根据它的值判断是应该将报文数据当作即时浏览的内容，还是可下载的附件。  

* 形成模版技术的4个要素：  
  * 模版语言  
  * 包含模版语言的模版文件  
  * 拥有动态数据的数据对象  
  * 模版引擎  












