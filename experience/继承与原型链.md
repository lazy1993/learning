# 继承与原型链

## 概念
* JavaScript 有点令人困惑，因为它是动态的，并且本身不提供一个 class 实现。（在 ES2015/ES6 中引入了 class 关键字，但只是语法糖，JavaScript 仍然是基于原型的）。  

* 当谈到继承时，JavaScript 只有一种结构：对象。  
    * 每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的原型对象（ prototype ）。  
    * 该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null。  
    * 根据定义，null 没有原型，并作为这个原型链中的最后一个环节。  

## 基于原型链的继承

* JavaScript 对象有一个指向一个原型对象的链。  

* 当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。  

* 遵循ECMAScript标准，`someObject.[[Prototype]]` 符号是用于指向 someObject的原型。  

* 从 ECMAScript 6 开始，[[Prototype]] 可以通过 Object.getPrototypeOf() 和 Object.setPrototypeOf() 访问器来访问。这个等同于 JavaScript 的非标准但许多浏览器实现的属性 __proto__。  

* 但它不应该与构造函数 func 的 prototype 属性相混淆。被构造函数创建的实例对象的 `[[prototype]]` 指向 func 的 prototype 属性。  

* 在 JavaScript 里，任何函数都可以添加到对象上作为对象的属性。  

* 在 JavaScript 中，构造器其实就是一个普通的函数。  

* 当使用 new 操作符 来作用这个函数时，它就可以被称为构造方法（构造函数）。  

* 在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。  

* 试图访问不存在的属性时会遍历整个原型链。  

* 遍历对象的属性时，原型链上的每个可枚举属性都会被枚举出来。  

* 错误实践：扩展原生对象的原型。这种技术被称为猴子补丁并且会破坏封装。  

## prototype

* 函数有一个叫做 prototype 的特殊属性。该特殊属性可与 JavaScript 的 new 操作符一起使用。对原型对象的引用被复制到新实例的内部 `[[Prototype]]` 属性。  

* 在 prototype 中定义的所有内容都可以由所有实例有效共享，甚至可以更改部分 prototype ，并在所有现有实例中显示更改（如果需要）。  

## 注意

* 在编写使用它的复杂代码之前，理解原型继承模型是至关重要的。  

* 请注意代码中原型链的长度，并在必要时将其分解，以避免可能的性能问题。  

* 原生原型不应该被扩展，除非它是为了与新的 JavaScript 特性兼容。  
